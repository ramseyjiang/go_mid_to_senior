package main

import (
	"fmt"
	"io"
	"net/http"
	"sync"
	"time"

	"go.uber.org/ratelimit"
)

func Get(url string) ([]byte, int, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, resp.StatusCode, err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, resp.StatusCode, err
	}
	return body, resp.StatusCode, nil

}

// Task struct is used to store the result of each request and response.
type Task struct {
	taskNum    int
	url        string
	data       []byte
	err        string
	statusCode int
	duration   time.Duration
	workerName string
}

func (t Task) String() string {
	return fmt.Sprintf("taskNum: %d, url: %s, workerName: %s ,duration: %d, statusCode: %d, err: %s nothing, and extension...", t.taskNum, t.url, t.workerName, t.duration, t.statusCode, t.err)
}

// worker is used to handle the task from the taskChan, and send the result to the resultsChan.
// taskChan is requests container chan,
// resultChan is responses container chan,
func worker(name string, taskChan <-chan Task, resultChan chan<- Task) {
	for task := range taskChan {
		start := time.Now()
		body, code, err := Get(task.url)
		if err != nil {
			task.err = err.Error()
		}
		task.statusCode = code
		task.data = body
		task.workerName = name
		task.duration = time.Duration(time.Since(start).Milliseconds())
		resultChan <- task
	}
}

// producer component generates all tasks and sends them to Task Chan for the downstream process.
func producer(rl ratelimit.Limiter) <-chan Task {
	var tasks []Task
	for i := 0; i < 1000; i++ {
		url := "https://httpbin.org/get?i=" + fmt.Sprintf("%d", i)
		tasks = append(tasks, Task{taskNum: i, url: url})
	}
	fmt.Println("total urls: ", len(tasks))

	out := make(chan Task)
	go func() {
		defer close(out)
		for _, task := range tasks {
			rl.Take()
			out <- task
		}
	}()

	return out
}

func main() {
	// The rate limiter package defines the leaky-bucket rate limit algorithm implementation.
	// use the rate limiter to control the task generation speed.
	// code below is the created a rate limiter with a limit of 1000 requests per minute. The num 1000, it can be changed.
	rl := ratelimit.New(1000, ratelimit.Per(60*time.Second)) // per second

	// taskChan is a task container; it includes all generated requests.
	taskChan := producer(rl)

	// Result Chan is another task container; it includes all the finished responses(tasks) and their results generated by the worker.
	resultsChan := make(chan Task)

	// start 5 workers
	numWorker := 5
	var wg sync.WaitGroup
	for i := 0; i < numWorker; i++ {
		wg.Add(1)
		go func(x int) {
			defer wg.Done()
			worker(fmt.Sprintf("worker-%d", x), taskChan, resultsChan)
		}(i)
	}

	// the necessary goroutine to close the resultChan
	go func() {
		wg.Wait()
		close(resultsChan)
	}()

	for result := range resultsChan {
		fmt.Println(result)
	}
}
