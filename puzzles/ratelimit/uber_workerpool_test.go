package ratelimit

import (
	"fmt"
	"log"
	"net/http"
	"sync"
	"testing"
	"time"

	"go.uber.org/ratelimit"
)

func TestUberWorkerPool(t *testing.T) {
	tests := map[int]struct {
		taskNum int
		taskUrl string
	}{
		0: {
			taskNum: 0,
			taskUrl: "https://httpbin.org/get?i=0",
		},
		1: {
			taskNum: 1,
			taskUrl: "https://httpbin.org/get?i=1",
		},
		2: {
			taskNum: 2,
			taskUrl: "https://httpbin.org/get?i=2",
		},
		3: {
			taskNum: 3,
			taskUrl: "https://httpbin.org/get?i=3",
		},
		4: {
			taskNum: 4,
			taskUrl: "https://httpbin.org/get?i=4",
		},
	}

	// The rate limiter package defines the leaky-bucket rate limit algorithm implementation.
	// use the rate limiter to control the task generation speed.
	// code below is the created a rate limiter with a limit of 8 requests per minute. The num 10, it can be changed.
	rl := ratelimit.New(5, ratelimit.Per(5*time.Second)) // per second

	// taskChan is a task container; it includes all generated requests.
	taskChan := producer(rl)

	// Result Chan is another task container; it includes all the finished responses(tasks) and their results generated by the worker.
	resultsChan := make(chan Task)

	// start 5 workers
	numWorker := 5
	var wg sync.WaitGroup
	for i := 0; i < numWorker; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			worker(fmt.Sprintf("worker-%d", i), taskChan, resultsChan)
		}(i)
	}

	// the necessary goroutine to close the resultChan
	go func() {
		wg.Wait()
		close(resultsChan)
	}()

	for result := range resultsChan {
		// fmt.Printf("taskNum: %d, url: %s, workerName: %s ,duration: %d, statusCode: %d, err: %s nothing, and extension...\n",
		// 		result.taskNum, result.url, result.workerName, result.duration, result.statusCode, result.err)
		t.Run("workerPool", func(t *testing.T) {
			if tests[0].taskUrl == result.url && tests[0].taskNum == result.taskNum && result.statusCode == http.StatusOK {
				log.Println(result.url)
			}

			if tests[1].taskUrl == result.url && tests[1].taskNum == result.taskNum && result.statusCode == http.StatusOK {
				log.Println(result.url)
			}

			if tests[2].taskUrl == result.url && tests[2].taskNum == result.taskNum && result.statusCode == http.StatusOK {
				log.Println(result.url)
			}

			if tests[3].taskUrl == result.url && tests[3].taskNum == result.taskNum && result.statusCode == http.StatusOK {
				log.Println(result.url)
			}

			if tests[4].taskUrl == result.url && tests[4].taskNum == result.taskNum && result.statusCode == http.StatusOK {
				log.Println(result.url)
			}
		})
	}
}
